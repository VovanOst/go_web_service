package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"hw11_shopql/graph/model"
	"hw11_shopql/service"
	"log"
	"strconv"
)

// Items is the resolver for the items field.
func (r *catalogResolver) Items(ctx context.Context, obj *model.Catalog, limit *int, offset *int) ([]*model.Item, error) {
	log.Printf("[DEBUG] Catalog.Items for catalog %d, limit=%v, offset=%v", obj.ID, limit, offset)

	all := obj.Items

	// default offset = 0
	off := 0
	if offset != nil {
		off = *offset
	}
	// default limit = 3
	lim := 3
	if limit != nil {
		lim = *limit
	}

	end := off + lim
	if end > len(all) {
		end = len(all)
	}

	sliced := all[off:end]
	log.Printf("[DEBUG] Returning %d of %d items: ids=%v", len(sliced), len(all), func() []int {
		ids := make([]int, len(sliced))
		for i, it := range sliced {
			ids[i] = it.ID
		}
		return ids
	}())

	return sliced, nil
}

// InCart is the resolver for the inCart field.
func (r *itemResolver) InCart(ctx context.Context, obj *model.Item) (int, error) {
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return 0, errors.New("User not authorized")
	}

	// Достаём корзину из сервиса
	cart, ok := r.Svc.Carts[userID]
	if !ok {
		// ещё нет корзины — значит, 0
		return 0, nil
	}

	// Ключ — строковое представление ID
	key := strconv.Itoa(obj.ID)
	if ci, exists := cart.Items[key]; exists {
		return ci.Quantity, nil
	}

	return 0, nil
}

// InStockText is the resolver for the inStockText field.
func (r *itemResolver) InStockText(ctx context.Context, obj *model.Item) (string, error) {
	switch {
	case obj.Stock <= 1:
		return "мало", nil
	case obj.Stock <= 3:
		return "хватает", nil
	default:
		return "много", nil
	}
}

// AddToCart is the resolver for the AddToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, in model.AddToCartInput) ([]*model.CartItem, error) {
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, errors.New("User not authorized")
	}
	item, ok := r.Svc.Items[in.ItemID]
	if !ok {
		return nil, errors.New("item not found")
	}
	if in.Quantity > item.Stock {
		return nil, errors.New("not enough quantity")
	}

	// Получаем или создаём Cart
	cart, ok := r.Svc.Carts[userID]
	if !ok {
		cart = &service.Cart{
			Items: make(map[string]*model.CartItem),
			Order: []string{},
		}
		r.Svc.Carts[userID] = cart
	}

	key := in.ItemID
	if ci, exists := cart.Items[key]; exists {
		ci.Quantity += in.Quantity
	} else {
		cart.Items[key] = &model.CartItem{
			Item:     item,
			Quantity: in.Quantity,
		}
		cart.Order = append(cart.Order, key)
	}

	item.Stock -= in.Quantity

	return cartItemsSlice(cart), nil
}

// RemoveFromCart is the resolver for the RemoveFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, in model.RemoveFromCartInput) ([]*model.CartItem, error) {
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, errors.New("User not authorized")
	}

	cart, ok := r.Svc.Carts[userID]
	if !ok {
		return nil, errors.New("cart is empty")
	}

	key := in.ItemID
	ci, exists := cart.Items[key]
	if !exists {
		return nil, errors.New("item not in cart")
	}
	if ci.Quantity < in.Quantity {
		return nil, errors.New("insufficient quantity in cart")
	}

	ci.Quantity -= in.Quantity
	// Восстанавливаем остаток на складе
	if item, ok := r.Svc.Items[in.ItemID]; ok {
		item.Stock += in.Quantity
	}

	if ci.Quantity == 0 {
		delete(cart.Items, key)
		// Оставляем key в cart.Order — cartItemsSlice его пропустит
	}

	return cartItemsSlice(cart), nil
}

// Catalog is the resolver for the Catalog field.
func (r *queryResolver) Catalog(ctx context.Context, id string) (*model.Catalog, error) {
	// Пример: ищем нужный каталог в сервисном слое по ID
	if cat, ok := r.Svc.Catalogs[id]; ok {
		return cat, nil
	}
	return nil, errors.New("catalog not found")
}

// Seller is the resolver for the Seller field.
func (r *queryResolver) Seller(ctx context.Context, id string) (*model.Seller, error) {
	if seller, ok := r.Svc.Sellers[id]; ok {
		return seller, nil
	}
	return nil, errors.New("seller not found")
}

// MyCart is the resolver for the MyCart field.
func (r *queryResolver) MyCart(ctx context.Context) ([]*model.CartItem, error) {
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, errors.New("User not authorized")
	}
	cart, ok := r.Svc.Carts[userID]
	if !ok {
		// Возвращаем пустой срез, а не 0 или nil
		return []*model.CartItem{}, nil
	}
	return cartItemsSlice(cart), nil
}

// Items is the resolver for the items field.
func (r *sellerResolver) Items(ctx context.Context, obj *model.Seller, limit *int, offset *int) ([]*model.Item, error) {
	// Логируем входные параметры для отладки
	log.Printf("[DEBUG] Seller.Items called: sellerID=%d, limit=%v, offset=%v",
		obj.ID, limit, offset,
	)

	all := obj.Items

	// default offset = 0
	off := 0
	if offset != nil {
		off = *offset
	}
	if off > len(all) {
		return []*model.Item{}, nil
	}

	// default limit = 3
	lim := 3
	if limit != nil {
		lim = *limit
	}

	end := off + lim
	if end > len(all) {
		end = len(all)
	}

	sliced := all[off:end]
	// Логируем, что возвращаем
	var ids []int
	for _, it := range sliced {
		ids = append(ids, it.ID)
	}
	log.Printf("[DEBUG] Seller.Items returning %d of %d items: ids=%v",
		len(sliced), len(all), ids,
	)

	return sliced, nil
}

// Catalog returns CatalogResolver implementation.
func (r *Resolver) Catalog() CatalogResolver { return &catalogResolver{r} }

// Item returns ItemResolver implementation.
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Seller returns SellerResolver implementation.
func (r *Resolver) Seller() SellerResolver { return &sellerResolver{r} }

type catalogResolver struct{ *Resolver }
type itemResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sellerResolver struct{ *Resolver }
