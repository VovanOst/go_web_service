package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"fmt"
	"hw11_shopql/graph/model"
)

// AddToCart is the resolver for the AddToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, in model.AddToCartInput) ([]*model.CartItem, error) {
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, errors.New("user not authorized")
	}

	// Находим товар по ID
	item, ok := r.Svc.Items[in.ItemID]
	if !ok {
		return nil, errors.New("item not found")
	}

	// Получаем или создаём корзину для пользователя
	userCart, ok := r.Svc.Carts[userID]
	if !ok {
		userCart = make(map[string]*model.CartItem)
		r.Svc.Carts[userID] = userCart
	}

	// Проверяем наличие на складе
	currentQty := 0
	if ci, exist := userCart[in.ItemID]; exist {
		currentQty = ci.Quantity
	}
	if currentQty+in.Quantity > item.Stock {
		return nil, errors.New("not enough quantity in stock")
	}

	// Добавляем товар в корзину
	if ci, exist := userCart[in.ItemID]; exist {
		ci.Quantity += in.Quantity
	} else {
		userCart[in.ItemID] = &model.CartItem{
			Item:     item, // ← исправлено
			Quantity: in.Quantity,
		}
	}

	return mapCartItemsToSlice(userCart), nil
}

// RemoveFromCart is the resolver for the RemoveFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, in model.RemoveFromCartInput) ([]*model.CartItem, error) {
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, errors.New("user not authorized")
	}

	userCart, ok := r.Svc.Carts[userID]
	if !ok {
		return nil, errors.New("cart is empty")
	}

	ci, exist := userCart[in.ItemID]
	if !exist {
		return nil, errors.New("item not in cart")
	}

	if ci.Quantity < in.Quantity {
		return nil, errors.New("insufficient quantity in cart")
	}

	ci.Quantity -= in.Quantity
	if ci.Quantity == 0 {
		delete(userCart, in.ItemID)
	}

	return mapCartItemsToSlice(userCart), nil
}

// Catalog is the resolver for the Catalog field.
func (r *queryResolver) Catalog(ctx context.Context, id string) (*model.Catalog, error) {
	// Пример: ищем нужный каталог в сервисном слое по ID
	if cat, ok := r.Svc.Catalogs[id]; ok {
		return cat, nil
	}
	return nil, errors.New("catalog not found")
}

// Seller is the resolver for the Seller field.
func (r *queryResolver) Seller(ctx context.Context, id string) (*model.Seller, error) {
	if seller, ok := r.Svc.Sellers[id]; ok {
		return seller, nil
	}
	return nil, errors.New("seller not found")
}

// MyCart is the resolver for the MyCart field.
func (r *queryResolver) MyCart(ctx context.Context) ([]*model.CartItem, error) {
	panic(fmt.Errorf("not implemented: MyCart - MyCart"))
}

// Items is the resolver for the items field.
func (r *sellerResolver) Items(ctx context.Context, obj *model.Seller, limit *int, offset *int) ([]*model.Item, error) {
	panic(fmt.Errorf("not implemented: Items - items"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Seller returns SellerResolver implementation.
func (r *Resolver) Seller() SellerResolver { return &sellerResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sellerResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

type itemResolver struct{ *Resolver }

func mapCartItemsToSlice(cart map[string]*model.CartItem) []*model.CartItem {
	var cartItems []*model.CartItem
	for _, ci := range cart {
		cartItems = append(cartItems, ci)
	}
	return cartItems
}
func (r *сatalogResolver) Childs(ctx context.Context, obj *model.Catalog) ([]*model.Catalog, error) {
	return obj.Childs, nil
}
